# 1.loader运行的总体流程
1. Compiler.js中会将用户配置与默认配置合并，其中就包括了loader部分
2. webpack就会根据配置创建两个关键的对象 ---NormalModuleFactory 和 ContextModuleFactory。它们相当于是两个类工厂，通过其可以创建相应的 NormalModule 和 ContextModule
3. 在工厂创建NormalModule实例之前还要通过loader的resolver来解析loader路径
4. 在NormalModule实例创建之后，则会通过其build()方法来进行模块的构建。构建模块的第一步就是使用loader来加载并处理模块内容。而loader-runner这个库就是 webpack 中 loader的运行器
5. 最后，将loader处理完的模块内容输出，进入后续的编译流程

![](/public/images/loader.png)

# 2.loader配置
loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loaderAPI, 并通过 this 上下文访问。
## 2.1 匹配（test）单个 loader
匹配（test）单个 loader,你可以简单通过在rule对象设置path.resolve指向这个本地文件
```js
{
    test: /\.js$/,
    use: [
        {
            loader: path.resolve('path/to/loader.js'),
            options: { /* ... */}
        }
    ]
}
```
## 2.2 匹配（test）多个 loaders
你可以使用 resolveLoader.modules配置，webpack将会从这些目录中搜索这些loaders。
```js
resolveLoader: {
    modules: [path.resolve('node_modules'), path.resolve(__dirname, 'src', 'loaders')]
}
```
## 2.3 npm link
- 第1步：确保正在开发的本地Npm模块(也就是正在开发的Loader)的package.json已经正确配置好
- 第2步：在本地npm模块根目录下执行 npm link，把本地模块注册到全局
- 第3步：在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 npm 模块链接到项目的 node_modules 目录下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称
```js
npm link
```
## 2.4 alias
```js
resolveLoader: {
    alias: {
        "babel-loader": resolve('./loaders/babel-loader.js'),
        "css-loader": resolve('./loaders/css-loader.js'),
        "style-loader": resolve('./loaders/style-loader.js'),
        "file-loader": resolve('./loaders/file-loader.js'),
        "url-loader": resolve('./loaders/url-loader.js')
    }
}
```
# 3.loader用法
## 3.1 单个loader用法
- loader只能传入一个包含包含资源文件内容的字符串
- 同步loader可以简单的返回一个代表模块转化后的值
- loader 也可以通过使用 this.callback(err, values...)函数，返回任意数量的值
- loader 会返回一个或者两个值。第一个值类型是 JavaScript 代码的字符串或者 buffer. 第二个参数值是 SourceMap,它是个JavaScript对象
## 3.2 多个loader
- 当链式调用多个 loader 的时候，请记住它们会以相反的顺序执行。取决于数组写法格式，从右向左或者从下向上执行。
- 最后的 loader 最早调用，将会传入原始资源内容。
- 第一个 loader 最后调用，期望值是传出 JavaScript 和 source map（可选）
- 中间的 loader 执行时，会传入前一个 loader 传出的结果。

# 4.用法准则
## 4.1 简单
- loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用.
## 4.2 链式(Chaining)
- 利用 loader 可以链式调用的优势。写五个简单的 loader 实现五项任务，而不是一个 loader 实现五项任务。
## 4.3 模块化(Modular)
保证输出模块化。loader生成的模块与普通模块遵循相同的设计原则。
## 4.4 无状态（Stateless）
确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。
## 4.5 loader 工具库
- [loader-utils](https://github.com/webpack/loader-utils) 包。它提供了许多有用的工具，但是最常用的一种工具是获取传递给 loader 的选项
- [schema-utils]包配合 loader-utils,用于保证 loader 选项，进行与JSON Schema结构一致的校验
## 4.6 loader 依赖
如果一个 loader 使用外部资源（例如，从文件系统读取），必须声明它。这些信息用于使缓存 loaders 无效，以及在观察模式(watch mode)下重编译。
## 4.7 模块依赖
根据模块类型，可能会有不同的模式指定依赖关系。例如在CSS中，使用@import 和 url(...) 语句来声明依赖，这些依赖关系应该由模块系统解析。
## 4.8 绝对路径
- 不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化。
- loader-utils 中的 stringifyRequest 方法，可以将绝对路径转化为相对路径。
## 4.9 同等依赖
- 如果你的 loader 简单包裹另外一个包，你应该把这个包作为一个 peerDependency 引入。
- 这种方式允许应用程序开发者在必要情况下，在package.json中指定所需的确定版本。

# 5.API
## 5.1 缓存结果
- 在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变的非常缓慢。为此，Webpack会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时，是不会重新调用对应的Loader去执行转换操作的。
```js
module.exports = function(source) {
    // 关闭该 Loader 的缓存功能
    this.cacheable(false);
    return source;
}
```
## 5.2 异步
- Loader 有同步和异步之分，上面介绍的Loader都是同步的Loader,因为它们的转换流程都是同步的，转换完成后再返回结果。
- 但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得到结果，如果采用同步的方式网络请求就会阻塞整个构建，导致构建非常缓慢
```js
module.exports = function(source) {
    // 告诉 Webpack 本次转换是异步的，Loader会在 callback 中回调结果
    var callback = this.async();
    someAsyncOperation(source, function(err, result, sourceMaps, ast) {
        // 通过 callback 返回异步执行后的结果
        callback(err, result, sourceMaps, ast);
    });
};
```
## 5.3 返回其他结果
Loader 有些场景下还需要返回除了内容之外的东西。
```js
module.exports = function(source) {
    // 通过 this.callback 告诉 Webpack 返回的结果
    this.callback(null, source, sourceMaps);
    // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined,
    // 以让 Webpack 直到该 Loader 返回的结果在 this.callback 中，而不是 return 中
    return;
}
```
完整格式
```js
this.callback(
    // 当无法转换原内容时，给 Webpack 返回一个 Error
    err: Error | null,
    // 原内容转换后的内容
    content: string | Buffer,
    // 用于把转换后的内容得出原内容的 Source Map，方便调试
    sourceMap?: SourceMap,
    // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，
    // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能
    abstractSyntaxTree?: AST
);
```
## 5.4 raw loader
- 在默认的情况下， Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。
- 但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，列如 file-loader, 就需要 Webpack 给 Loader 传入二进制格式的数据。为此，你需要这样编写 Loader
```js
module.exports = function(source) {
    // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的
    source instanceof Buffer === true;
    // Loader 返回的类型也可以是Buffer类型的
    // 在 exports.raw !== true 时， Loader 也可以返回 Buffer 类型的结果
    return source;
};
// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据
module.exports.raw = true;
```
## 5.5 获得options
- 可以获得给 Loader 配置的 options
```js
const loaderUtils = require('loader-utils');
module.exports = function(source) {
    // 获取到用户给当前 Loader 传入的 options
    const options = loaderUtils.getOptions(this);
    return source;
};
```
## 5.6 其他 Loader API
- [完整API](https://webpack.js.org/api/loaders/)

| 方法名 | 含义 |
| --- | --- |
| this.context | 当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src |
| this.resource | 当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。|
| this.resourcePath | 当前处理文件的路径，例如 /src/main.js |
| this.resourceQuery | 当前处理文件的 querystring |
| this.target | 等于 Webpack 配置中的 Target |
| this.loadModule | 但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时,就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果 |
| this.resolve | 像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string)) |
| this.addDependency | 给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string) |
| this.addContextDependency | 和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string) |
| this.clearDependencies | 清除当前正在处理文件的所有依赖，使用方法为 clearDependencies() |
| this.emitFile | 输出一个文件，使用方法为 emitFile(name: string, content: Buffer/string, sourceMap: {...}) |
| loader-utils.stringifyRequest | Turns a request into a string that can be used inside require() or import while avoiding absolute paths. Use it instead of JSON.stringify(...) if you're generating code inside a loader 把一个请求字符串转成一个字符串，以便能在require或者import中使用以避免绝对路径。如果你在一个loader中生成代码的话请使用这个而不要用JSON.stringify() |
| loader-utils.interpolateName | Interpolates a filename template using multiple placeholders and/or a regular expression. The template and regular expression are set as query params called name and regExp on the current loader's context. 使用多个占位符或一个正则表达式转换一个文件名的模块。这个模板和正则表达式被设置为查询参数，在当前loader的上下文中被称为name或者regExp |

# 6.loader实战
## 6.1 项目准备
```js
cnpm i webpack webpack-cli webpack-dev-server html-webpack-plugin @babel/core @babel/preset-env babel-loader css-loader file-loader less less-loader style-loader url-loader -D
```
### 6.1.1 webpack.config.js
```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    mode: 'development',
    context: process.cwd(),
    devtool: 'source-map',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    },
    resolveLoader: {
        modules: [path.resolve('./loaders'), 'node_modules']
    },
    devServer: {
        contentBase: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                use: {
                    loader: 'babel-loader'
                },
                include: path.join(__dirname, 'src'),
                exclude: /node_modules/
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/index.html'
        })
    ]
};
```
### 6.1.2 src\index.js
src\index.js
```js
const sum = (a, b) => {
    return a + b;
}
console.log(sum(1, 2));
```
### 6.1.3 src\index.html
src\index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="root"></div>
</body>
</html>
```
## 6.2 babel-loader
- [babel-loader](https://github.com/babel/babel-loader/blob/master/src/index.js)
- [@babel/core](https://babeljs.io/docs/en/next/babel-core.html)

| 属性 | 值 |
| --- | --- |
| this.request | /loaders/babel-loader.js!/src/index.js' |
| this.userRequest | ./src/index.js |
| this.rawRequest | ./src/index.js |
| this.resourcePath | ./src/index.js |

```js
const babel = require('@babel/core');
function loader(source) {
    // //C:\vipdata\prepare6\zhufeng_loader\loaders\babel-loader.js!C:\vipdata\prepare6\zhufeng_loader\src\index.js
    console.log('this.request', this.request);
    const options = {
        presets: ['@babel/preset-env'],
        //sourceMaps: true 如果没有此参数，则不会生成sourcemap文件
        //注意此处的sourceMap是从转译前的代码到转译后的代码的map映射,如果此处不生成无法调试真正的源码了
        sourceMaps: true,
        //如果没有此参数则生成的map文件里文件中unknown
        filename: this.request.split('!')[1].split('/').pop()
    }
    //在webpack.config.js中 增加devtool: 'source-map',这个source-map是从转译后的源码到bundle.js之间的map映射
    let { code, map, ast } = babel.transform(source, options);
    return this.callback(null, code, map, ast);
}
module.exports = loader;
```
> 本案例是学习如何编写loader以及如何通过this.callback返回多个值

## 6.3 banner-loader
- 本案例学习如何获取参数，验证参数，实现异步loader以及使用缓存
### 6.3.1 banner-loader.js
loaders\banner-loader.js
```js
const loaderUtils = require('loader-utils');
const validateOptions = require('schema-utils');
const fs = require('fs');
function loader(source) {
    // 把 loader 改为异步，任务完成后需要手工执行callback
    let cb = this.async();
    // 启用 loader 缓存
    this.cacheable && this.cacheable();
    // 用来验证options的合法性
    let schema = {
        type: 'object',
        properties: {
            filename: {
                type: 'string'
            },
            text: {
                type: 'string'
            }
        }
    }
    // 通过工具方法获取options
    let options = loaderUtils.getOptions(this);
    // 用来验证options的合法性
    validateOptions(schema, options);
    let { filename } = options;
    fs.readFile(filename, 'utf8', (err, text) => {
        cb(err, text + source);
    });
}
module.exports = loader; 
```
### 6.3.2 banner.js
loaders\banner.js
```js
/** copyright: zhufengjiagou **/
```