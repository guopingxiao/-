# 1.MongoDB简介
- Mongodb是一个开源的NoSQL数据库，相比MySQL那样的关系型数据库，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。
- 同时它也是一个对象数据库，没有表和行的概念，也没有固定的模式和结构，所有的数据都是以文档的形式存储（文档，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组、甚至是一个嵌套文档），数据格式就是JSON。
# 2.Mongoose是什么？
- Mongoose是MongoDB的一个对象模型工具
- 同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的一些增删改查等常用方法
- 让NodeJS操作Mongodb数据库变得更加灵活简单
- Mongoose因为封装了MongoDB对文档操作的常用方法，可以高效处理mongodb,还提供了类似Schema的功能，如hook、plugin、virtual、populate等机制。
- 官网[mongoosejs](http://mongoosejs.com/)
# 3.使用mongoose
## 3.1 安装mongoose
```bash
$cnpm install mongoose -S
```
## 3.2 使用mongoose
```js
let mongoose = require("mongoose");
let db = mongoose.createConnection("mongodb://user:pass@ip:port/database", {useNewUrlParser: true, useUnifiedTopology: true});
```
- user 用户名
- pass 密码
- ip IP 地址
- port 端口号
- database 数据库
## 3.3 使用mongoose
```js
let mongoose = require('mongoose');
let connection = mongoose.createConnection("mongodb://127.0.0.1/zfpx", { useNewUrlParser: true, useUnifiedTopology: true});
connection.on('error', function(error) {
    console.log('数据库连接失败' + error);
});
connection.on('open', function(error) {
    console.log('数据库连接成功');
});
```
## 3.4 Schema
- Schema是数据库集合的模型骨架
- 定义了集合中的字段的名称和类型以及默认值等信息
### 3.4.1 Schema.Type
- NodeJS中的基本数据类型都属于Schema Type
- 另外Mongoose还定义了自己的类型
- 基本属性类型有
    - 字符串（String）
    - 日期型（Date）
    - 数值型（Number）
    - 布尔型（Boolean）
    - null
    - 数组（[]）
    - 内嵌文档
### 3.4.2 定义Schema
```js
var personSchema = new Schema({
    name: String, // 姓名
    binary: Buffer, // 二进制
    living: Boolean, // 是否活着
    birthday: Date, // 生日
    age: Number, // 年龄
    _id: Schema.Types.ObjectId, // 主键
    _fk: Schema.Types.ObjectId, // 外键
    array: [], // 数组
    arrOfString: [String], // 字符串数组
    arrOfNumber: [Number], // 数字数组
    arrOfDate: [Date], // 日期数组
    arrOfBuffer: [Buffer], // Buffer数组
    arrOfBoolean: [Boolean], // 布尔值数组
    arrOfObjectId: [Schema.Types.ObjectId] // 对象ID数组
    nested: {name: String} // 内嵌文档
});

    let p = new Person();
    p.name= 'zfpx';
    p.age = 25;
    p.birthday = new Date();
    p.married = false;
    p.mixed= {any:{other:'other'}};
    p._otherId = new mongoose.Types.ObjectId;
    p.hobby.push('smoking');
    p.ofString.push('string');
    p.ofNumber.pop(3);
    p.ofDates.addToSet(new Date);
    p.ofBuffer.pop();
    p.ofMixed = ['anything',3,{name:'zfpx'}];
    p.nested.name = 'zfpx';
```
### 3.4.3 Model
Model是由通过Schema构造而成 除了具有Schema定义的数据库骨架以外，还可以操作数据库 如何通过Schema来创建Model呢，如下
```js
var mongoose = require('mongoose');
var connection = mongoose.createConnection("mongodb://127.0.0.1/zfpx", {useNewUrlParser: true, useUnifiedTopology: true});
connection.on('error', function(error) {
    console.log('数据库连接失败:' + error);
})
connection.on('open', function(error) {
    console.log('数据库连接成功');
})
let PersonSchema = new mongoose.Schema({
    name: String, // 姓名
    age: Number, // 年龄
});
// 两个参数表示定义一个模型
var PersonModel = connection.model("Person", PersonSchema);
// 如果该Model已经定义，则可以直接通过名字获取
var PersonModel = connection.model('Person'); // 一个参数表示获取已定义的模型
```
> 拥有了Model,我们也就拥有了操作数据库的能力 在数据库中的集合名称等于 模型名转小写再转复数，比如Person -> person -> people, Child > child > children

### 3.4.4 Entity简述
- 通过Model创建的实体，它也可以操作数据
- 使用Model创建Entity, 如下示例
```js
let personEntity = new PersonModel({
    name: 'zhufeng',
    age: 6
});
console.log(personEntity); //{ _id: 5d9c70438e748c3ae032a7fd, name: 'zhufeng', age: 6 }
```
> Schema生成Model,Model创造Entity,Model和Entity都可对数据库操作，但Model比Entity可以实现的功能更多
### 3.4.5 保存Entity
```js
let mongoose = require('mongoose');
let conn = mongoose.createConnection("mongodb://127.0.0.1/zfpx",{ useNewUrlParser: true,useUnifiedTopology: true});
let PersonSchema = new mongoose.Schema({
    name: {type: String},
    age: {type: Number, default: 0}
});
let PersonModel = conn.model("Person", PersonSchema);
let PersonEntity = new PersonModel({
    name: 'zfpx',
    age: 6
});
PersonEntity.save(function(error, doc) {
    if(error) {
        console.log("error :" + error);
    } else {
        // doc是返回刚存的person对象
        console.log(doc);
    }
});
```
### 3.4.6 ObjectId
- 存储在mongodb集合中的每个文档都有一个默认的主键_id
- 这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId该类型的值由系统自己生成，从某种意义上几乎不会重复
- ObjectId使用12字节的存储空间，是一个由24个16进制数字组成的字符串（每个字节可以存储两个16进制数字）
5d9c70b3 f88966 4f24 d9caa5

| 部分 | 值 | 含义 |
| --- | --- | --- |
| 4字节 | 5d9c70b3 | 	时间戳是自 1970 年 1 月 1 日（08:00:00 GMT）至当前时间的总秒数，它也被称为 Unix 时间戳，单位为秒 |
| 3字节 | f88966 | 所在主机的唯一标识符,通常是机器主机名的散列值(hash),可以确保不同主机生成不同的ObjectId不产生冲突 |
| 2字节 | 4f24 | 产生ObjectId的进程的进程标识符(PID) |
| 3字节 | d9caa5 | 	由一个随机数开始的计数器生成的值 |

```js
let ts = parseInt('5d9c70b3', 16);
console.log(ts);
let date = new Date(ts*1000);
console.log(date.toLocaleString());

console.log(parseInt('4f24', 16)); // 20260
console.log(parseInt('d9caa5',16))//14273189
```
> 前9个字节保证了同一秒钟不同机器不同进程产生的ObjectId是唯一的，最后3个字节是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId也是不一样的，一秒钟最多允许每个进程拥有256的3次方（16777216）个不同的ObjectId,每一个文档都有一个特殊的键_id,这个键在文档所属的集合中是唯一的。

## 3.5 基础操作
### 3.5.1 查询
语法
```bash
Model.find(查询条件, callback);
```
代码
```js
Model.find({}, function(error, docs) {
    // 若没有问find传递参数，默认的是显示所有文档
});
Model.find({"age": 6}, function(error, docs) {
    if(error) {
        console.log("error:" + error);
    } else {
        console.log(docs); // docs: age为6的所有文档
    }
});
```